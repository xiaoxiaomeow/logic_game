import { parseFormula } from "/src/logic/Parser";
import { PropositionalLogic } from "/src/logic/LogicSystem";

export const axiom1 = parseFormula('p->!q');
export const axiom2 = parseFormula('p');
export const target = parseFormula('!q');

export const meta = {
	chapterId: "00_propositional_logic",
	id: "01_deduction",
	name: "Level.PropositionalLogic.Deduction.Name",
	statement: "$\\{p\\to\\lnot q,p\\}\\vdash \\lnot q$",
	logicSystem: PropositionalLogic,
	axioms: [axiom1, axiom2],
	target: target,
	type: "main"
}

import Speak from "/src/components/custom/Speak";
import ConversationProgresser from "/src/components/custom/ConversationProgresser";
import LocalizedMarkdown from "/src/components/custom/LocalizedMarkdown";
import Star from "/src/components/custom/Star";
import Sapphire from "/src/components/custom/Sapphire";
import FormulaLatex from "/src/components/custom/FormulaLatex";
import ResumeUntil from "/src/components/custom/ResumeUntil";

<ConversationProgresser>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Time to produce your own string! You will use the second rule: 

- (Deduction) If you have produced any string of the form $\varphi\to\psi$ and the string $\varphi$, then you can produce $\psi$. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
该制造你自己的字符串了！你会用到第二条规则：

- （推理）如果你已经制造了任何形如 $\varphi\to\psi$ 的字符串和字符串 $\varphi$，你就可以制造 $\psi$。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
What are $\varphi$ and $\psi$? 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
什么是 $\varphi$ 和 $\psi$？
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
They represents any string you like. For example, if you choose $\varphi$ to represent $p$, and $\psi$ to represent $\lnot q$, then the rule becomes: 

- If you have produced the string $p\to\lnot q$ and the string $p$, then you can produce $\lnot q$. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
它们代表你喜欢的任何字符串。比如说，如果你选择让 $\varphi$ 代表 $p$，并且让 $\psi$ 代表 $\lnot q$，那么这条规则就是：

- 如果你已经制造了字符串 $p\to\lnot q$ 的和字符串 $p$，你就可以制造 $\lnot q$。
</LocalizedMarkdown>
</Speak>

<Speak speaker="author">
<LocalizedMarkdown locale="en">
To use Deduction, navigate to the Proof tab of your Inventory, and click `Deduction` (or directly type `deduction` in the input bar). You also need to type a `$` symbol and then provide the line number where you produced $\varphi\to\psi$. 

The game can automatically detect whether and where you have produced $\varphi$. For instance, if you have produced $p\to\lnot q$ on the first line (with line number 0), you can excecuting `deduction $0` to use Deduction for $\varphi=p$ and $\psi=\lnot q$. 

When you excecute some rule, the produced string will be put before the line you're inspecting. Therefore, ensure that you have already produced  $\varphi\to\psi$ and $\varphi$ before this line, instead of after. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
要使用推理，打开物品栏的证明面板，然后点击 `推理`（或者直接在输入框里输入 `deduction`）。你还需要输入一个`$`符号，后面提供你制造出 $\varphi\to\psi$ 的行标。游戏可以自动检查你是否制造出了、在哪里制造出了 $\varphi$。

比如，你在第一行（行标 0）制造出了 $p\to\lnot q$ ，执行 `deduction $0` 就可以以 $\varphi=p$ 和 $\psi=\lnot q$ 使用推理。

当你执行一个规则时，新制造的字符串会被放在正在检查的行之前，因此确保你在此之前就制造好了 $\varphi\to\psi$ 和 $\varphi$，而不是之后。
</LocalizedMarkdown>
</Speak>

<ResumeUntil condition={proof => proof != null && proof.proofComplete()} text="ConversationProgresser.CompleteLevelToContinue"/>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
So $\varphi\to\psi$ means that if I can produce $\varphi$ then I can also produce $\psi$. That quite explains the arrow symbol. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
所以 $\varphi\to\psi$ 的意思是只要我能制造出 $\varphi$ 我就能制造出 $\psi$。怪不得它写作一个箭头。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Sure, that is exactly the intended meaning for $\varphi\to\psi$ in the game, which is called the **semantics** of a string. As long as you're not a construct robot, it is very benificial to know the semantics of strings to help you consider which strings you need to produce to reach the target. But semantics itselft does not work at all when producing strings: a string has convincing semantics does not mean you can produce that string. For instance, the semantics of $p\to p$, "if you can produce $p$ then you can also produce $p$", is clearly correct, but currently there is no way of producing $p\to p$ from scratch. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
确实，游戏给 $\varphi\to\psi$ 预想的意思就是这个，它被称作字符串的**语义**。只要你不是个构装体机器人，知道字符串的语义对思考该制造哪些字符串来达到最终目标会非常有帮助。但语义本身对制造字符串是毫无用处的：一个字符串的语义看起来是对的不代表你能制造出它。比如说，$p\to p$ 的语义“如果你能制造出 $p$ 你就能制造出 $p$”明显是正确的，但现在还没有办法从零开始制造出 $p\to p$。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
O...Okay. How should I read $\varphi\to\psi$? I suppose I can read it as "if $\varphi$ then $\psi$". 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
呃……好。$\varphi\to\psi$ 怎么读？我觉得它可以读作“如果 $\varphi$ 则 $\psi$”。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
You can also read it as "$\varphi$ implies $\psi$". 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
也可以读作“$\varphi$ 推出 $\psi$”。
</LocalizedMarkdown>
</Speak>

</ConversationProgresser>
