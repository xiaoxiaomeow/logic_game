import { parseFormula } from "/src/logic/Parser";
import { PropositionalLogic } from "/src/logic/LogicSystem";

export const p = parseFormula('p');
export const axiom = parseFormula('p->p');
export const target = parseFormula('(p->q)->p->q');
export const chapterId = "00_propositional_logic";

export const meta = {
	chapterId: chapterId,
	id: "03_substitution",
	name: "Level.PropositionalLogic.Substitution.Name",
	statement: "$\\{p\\to p\\}\\vdash (p\\to q)\\to p\\to q$",
	logicSystem: PropositionalLogic,
	axioms: [axiom],
	target: target,
	type: "main",
	prereqs: [{type: "level", chapterId: chapterId, levelId: "02_association"}]
}

import Speak from "/src/components/custom/Speak";
import ConversationProgresser from "/src/components/custom/ConversationProgresser";
import LocalizedMarkdown from "/src/components/custom/LocalizedMarkdown";
import Star from "/src/components/custom/Star";
import Sapphire from "/src/components/custom/Sapphire";
import FormulaLatex from "/src/components/custom/FormulaLatex";
import ResumeUntil from "/src/components/custom/ResumeUntil";

<ConversationProgresser>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
This is the last rule: 

- (Substitution) If $\varphi$ is any formula you have produced, <FormulaLatex formula={p} /> is an atomic formula and $\psi$ is any formula, then you can also produce the formula obtained by replacing every <FormulaLatex formula={p} /> in $\varphi$ with $\psi$. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
这是最后一条规则：

- （替换）如果 $\varphi$ 是任意你制造好的公式，<FormulaLatex formula={p} /> 是任意原子公式，$\psi$ 是任意公式，那么你可以制造通过把 $\varphi$ 中的 <FormulaLatex formula={p} /> 全部替换为 $\psi$ 得到的公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Although I already feel like these strings should be called formulas, but you finally admitted it! But what exactly is a formula, just any string? And what is this atomic formula? 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
虽然我早就感觉这些字符串应该被叫做公式，但你终于承认了！不过具体什么是公式，任何字符串都可以吗？还有这个原子公式是什么？
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Generally, a formula cannot be every string, it needs to be a string that makes sense: as a counterexample, $\to p\to\to$ is not a formula. That said, every string you'll encounter and deal with in this chapter will be a formula. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
一般来说，不是每个字符串都是公式，公式需要是个有意义的字符串：作为反例，$\to p\to\to$ 就不是公式。虽然这么说，你这一章里遇到和处理的所有字符串都会是公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
More precisely, an **atomic formula** is just some letter or word that you like. <Sapphire /> often use atomic formulas <FormulaLatex formula={p} />, <FormulaLatex formula={parseFormula("q")} />, <FormulaLatex formula={parseFormula("r")} />, but you can certainly use <FormulaLatex formula={parseFormula("t_5^7")} /> or <FormulaLatex formula={parseFormula("apple")} /> as an atomic formula if you want. Although recently the atomic formulas <Sapphire /> gives you are enough. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
具体来说，一个**原子公式**就是任何你喜欢的字母或者单词。<Sapphire />平常用的原子公式是 <FormulaLatex formula={p} />，<FormulaLatex formula={parseFormula("q")} />，<FormulaLatex formula={parseFormula("r")} />，但你想的话当然可以用 <FormulaLatex formula={parseFormula("t_5^7")} /> 或者 <FormulaLatex formula={parseFormula("apple")} /> 作为原子公式，不过短时间内你就用<Sapphire />给你的原子公式就够了。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
And then **formulas**. Firstly, every atomic formula is a formula. In addition, if $\varphi$ and $\psi$ are both formulas, then $\varphi\to\psi$ is also a formula. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
接下来是**公式**。首先，每个原子公式都是公式。此外，如果 $\varphi$ 和 $\psi$ 都是公式，那么 $\varphi\to\psi$ 也是公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
That's it? I was expecting more strings to be formulas. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
就这些？我还以为还有更多的字符串会是公式呢。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
That's it, well, for now. Later there will be some more. Back to the new rule, you can replace all occurances of some atomic formula <FormulaLatex formula={p} /> in a formula $\varphi$ by some other formula $\psi$. You need to have produced $\varphi$, but you don't need to have produced $\psi$. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
就这些，呃，现在就这些。之后还有些别的。回到新规则，你可以把某个公式 $\varphi$ 里出现的原子公式 <FormulaLatex formula={p} /> 全换成 $\psi$。你需要已经制造好了 $\varphi$，但你并不需要制造 $\psi$。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Let's see... I can now produce <FormulaLatex formula={axiom} /> as an axiom. So I can replace all <FormulaLatex formula={p} /> in it with, well, say, <FormulaLatex formula={parseFormula("q->\\textcolor{blue}{Sapphire}")} />. I have produced <FormulaLatex formula={parseFormula("(q->\\textcolor{blue}{Sapphire})->q->\\textcolor{blue}{Sapphire}")} />? 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
我看看……我现在可以制造公理 <FormulaLatex formula={axiom} />。所以我可以把里面的所有 <FormulaLatex formula={p} /> 都换成，呃，比如，<FormulaLatex formula={parseFormula("q->\\textcolor{blue}{Sapphire}")} />。我制造出了 <FormulaLatex formula={parseFormula("(q->\\textcolor{blue}{Sapphire})->q->\\textcolor{blue}{Sapphire}")} />？
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Correct. In some cases the replacement formula $\psi$ can also contain the atomic formula <FormulaLatex formula={p} /> you're replacing. These <FormulaLatex formula={p} /> do not get replaced recursively and remain <FormulaLatex formula={p} />. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
对的。有时候替换进来的公式 $\psi$ 里面也有你正在替换的原子公式 <FormulaLatex formula={p} />。这些 <FormulaLatex formula={p} /> 不会被递归地换掉，它们还是 <FormulaLatex formula={p} />。
</LocalizedMarkdown>
</Speak>

<Speak speaker="author">
<LocalizedMarkdown locale="en">
To use Substitution, navigate to the Proof tab of your Inventory, and click `Substitution` (or directly type `substitution` or `sub` in the input bar). You need to provide $\varphi$, <FormulaLatex formula={p} /> and $\psi$ in the exact order separated by space. You can type these formulas directly, or copy the code of a formula in the Formula Inspector tab. You can use a line number `$n` to replace $\varphi$, as before. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
要使用代入，打开物品栏的证明面板，然后点击 `代入`（或者直接在输入框里输入 `substitution` 或 `sub`）。你还需要按顺序提供 $\varphi$, <FormulaLatex formula={p} /> 和 $\psi$，中间用空格隔开。你可以直接输入这些公式，或者在公式信息面板复制一个公式的代码。像之前一样，你可以用一个行标 `$n` 来替换 $\varphi$。
</LocalizedMarkdown>
</Speak>

<ResumeUntil condition={ (level, _) => level.isCompleteOrModified() } text="ConversationProgresser.CompleteLevelToContinue"/>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Substitution is so powerful! I can produce a lots of different formulas from that single rule. And if I'm not mistaking, I can produce then **any** formula using this rule as long as I have produced the formula <FormulaLatex formula={p} />. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
代入真有用！我可以用这一条规则制造各种各样自己的字符串了。以及如果我没搞错的话，只要我制造出来了 <FormulaLatex formula={p} />，我就可以制造出来**所有**公式了。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Yes, and that is why you'll never be given <FormulaLatex formula={p} /> as an axiom again. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
是的，这也是为什么你之后再也不会获得 <FormulaLatex formula={p} /> 作为公理了。
</LocalizedMarkdown>
</Speak>

</ConversationProgresser>
