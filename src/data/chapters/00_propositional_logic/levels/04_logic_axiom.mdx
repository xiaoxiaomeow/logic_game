import { parseFormula } from "/src/logic/Parser";
import { PropositionalLogic } from "/src/logic/LogicSystem";

export const ptop = parseFormula('p->p');
export const ptoq = parseFormula('p->q');
export const target = parseFormula('p->p');
export const chapterId = "00_propositional_logic";

export const meta = {
	chapterId: chapterId,
	id: "04_logic_axiom",
	name: "Level.PropositionalLogic.LogicAxiom.Name",
	statement: "$\\vdash p\\to p$",
	logicSystem: PropositionalLogic,
	axioms: [],
	target: target,
	type: "main",
	prereqs: [{type: "level", chapterId: chapterId, levelId: "03_axiom_schema"}]
}

import Speak from "/src/components/custom/Speak";
import ConversationProgresser from "/src/components/custom/ConversationProgresser";
import LocalizedMarkdown from "/src/components/custom/LocalizedMarkdown";
import Star from "/src/components/custom/Star";
import Sapphire from "/src/components/custom/Sapphire";
import FormulaLatex from "/src/components/custom/FormulaLatex";
import ResumeUntil from "/src/components/custom/ResumeUntil";
import { Collapsible } from "@chakra-ui/react";

<ConversationProgresser>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
With the "weakening" axiom schema $\varphi\to\psi\to\varphi$, you still cannot prove <FormulaLatex formula={ptop} /> which looks certainly true. <Sapphire /> is aiming to give you enough axiom schemas that can prove all these semantically true formulas. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
有“弱化”公理模式 $\varphi\to\psi\to\varphi$ 之后，你还是没法证明 <FormulaLatex formula={ptop} /> 这种看起来很正确的公式。<Sapphire />的目标是给你足够多的公理模式来证明全部这些语义上正确的公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Just give me $\varphi$ as an axiom schema and I can prove every formula! 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
给我 $\varphi$ 作为公理模式，我就能证明所有公式了！
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
You wish. Also, <Sapphire /> do not want you to prove any formula that is not semantically true (or not true in general), for instance <FormulaLatex formula={ptoq} />. After considering <Sapphire /> decide to give you the "weakening" axiom along with the new "chain" axiom as **logic axioms**, which will be included as axiom schemas in every level from now on: 

- (Weakening) $\varphi\to\psi\to\varphi$
- (Chain) $(\varphi\to\psi\to\chi)\to(\varphi\to\psi)\to\varphi\to\chi$

As before, here $\varphi,\psi,\chi$ stand for any formulas. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
又做梦了。而且<Sapphire />也不想让你证明任何语义上不正确（或者一般来说不正确）的公式，比如说 <FormulaLatex formula={ptoq} />。<Sapphire />思考之后决定给你“弱化”公理和新的“链”公理作为**逻辑公理**——之后每一关都会有它们作为公理模式：

- （弱化）$\varphi\to\psi\to\varphi$
- （链）$(\varphi\to\psi\to\chi)\to(\varphi\to\psi)\to\varphi\to\chi$

和之前一样，这里 $\varphi,\psi,\chi$ 代表任意公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
The chain axiom looks complicated. Let's see... it means if I can prove $\varphi\to\psi\to\chi$, $\varphi\to\psi$ and $\varphi$, then I can prove $\chi$. To do this I just use deduction trice. Well, I'm convinced that this axiom is semantically true, but why picking this scary one? 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
链公理看起来好复杂。我想想……它的意思是如果我能证明 $\varphi\to\psi\to\chi$、$\varphi\to\psi$ 和 $\varphi$，那么我就能证明 $\chi$。我只要用三次推理就行了。嗯，那这个公理是语义上确实是正确的，但为什么要选这么吓人的一个公理？
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Thats because surprisingly only these two axiom schemas are enough to justify the semantics of $\to$. You can actually now prove every that looks true, including the most basic <FormulaLatex formula={ptop} />. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
这是因为很神奇地仅仅这两个公理模式就足以刻画 $\to$ 的语义了。你现在实际上可以证明所有看起来正确的东西，包括最基本的 <FormulaLatex formula={ptop} />。
</LocalizedMarkdown>
</Speak>

<Speak speaker="author">
<LocalizedMarkdown locale="en">
Since logic axioms are always available in every level from this one, they are no longer displayed on the level panel, and also you locate them in the Logic Axioms tab of your Inventory instead of the Axioms tab. But they are axioms, so using them is the same as before. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
由于逻辑公理从这一关开始的每一关都可用，它们不再显示在关卡面板上，以及你要从物品栏里的逻辑公理面板找它们，而不是公理面板。但它们还是公理，所以使用方法和原来一样。
</LocalizedMarkdown>
</Speak>

<Speak speaker="author">
<LocalizedMarkdown locale="en">
<Collapsible.Root>
<Collapsible.Trigger>
**Warning: this level is difficult.** Click here for hints if you are stuck. 
</Collapsible.Trigger>
<Collapsible.Content>
Consider using the chain axiom schema with $\varphi=p$, $\psi=p\to p$, $\chi=p$. 
</Collapsible.Content>
</Collapsible.Root>
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
<Collapsible.Root>
<Collapsible.Trigger>
**警告：这一关很难。** 如果没有什么进展，点击这里可以看到提示。
</Collapsible.Trigger>
<Collapsible.Content>
考虑对 $\varphi=p$, $\psi=p\to p$, $\chi=p$ 使用链公理。
</Collapsible.Content>
</Collapsible.Root>
</LocalizedMarkdown>
</Speak>

<ResumeUntil condition={ (level, _) => level.isCompleteOrModified() } text="ConversationProgresser.CompleteLevelToContinue"/>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Finally finished! I actually start to get into the game. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
终于做完了！我其实开始喜欢上这个游戏了。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
That's good to hear. <Sapphire /> just give you a quick hint: later we will show that a formula is **syntactically true**, or **provable**, if and only if it is **semantically true**. Therefore you can never prove a formula that is semantically not true / not true in general. If you ever find yourself trying to prove something like <FormulaLatex formula={parseFormula("p->q")} />, you'd better look for another way. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
那很好了。<Sapphire />给你一个小提示：之后我们会证明一个公式**语法**上正确，或者说**可证**，当且仅当它是**语义**上正确的。因此你永远没法证明一个语义上不正确 / 一般来说不正确的公式。如果你发现自己在试图证明像 <FormulaLatex formula={parseFormula("p->q")} /> 这样的东西，你最好换个思路。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Okay. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
好哦。
</LocalizedMarkdown>
</Speak>

</ConversationProgresser>
