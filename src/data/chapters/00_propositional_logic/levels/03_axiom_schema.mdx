import { parseFormula } from "/src/logic/Parser";
import { PropositionalLogic } from "/src/logic/LogicSystem";
import { weakening } from "/src/logic/Axiom";

export const p = parseFormula('p');
export const q = parseFormula('q');
export const ptoqtop = parseFormula('p->q->p');
export const qtop = parseFormula('q->p');
export const conclusion = weakening.getAxiomFromFormulas([qtop, p]);
export const axiom = parseFormula('p->p');
export const target = parseFormula('p->p->p->p');
export const chapterId = "00_propositional_logic";

export const meta = {
	chapterId: chapterId,
	id: "03_axiom_schema",
	name: "Level.PropositionalLogic.AxiomSchema.Name",
	statement: "$\\{\\varphi\\to\\psi\\to\\varphi\\}\\vdash p\\to p\\to p\\to p$",
	logicSystem: PropositionalLogic,
	axioms: [weakening],
	target: target,
	type: "main",
	prereqs: [{type: "level", chapterId: chapterId, levelId: "02_association"}]
}

import Speak from "/src/components/custom/Speak";
import ConversationProgresser from "/src/components/custom/ConversationProgresser";
import LocalizedMarkdown from "/src/components/custom/LocalizedMarkdown";
import Star from "/src/components/custom/Star";
import Sapphire from "/src/components/custom/Sapphire";
import FormulaLatex from "/src/components/custom/FormulaLatex";
import ResumeUntil from "/src/components/custom/ResumeUntil";

<ConversationProgresser>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
You may have noticed that the deduction rule can only prove strings shorter than the ones you have proved. That means, after I give you finitely many axioms, you can pretty much determine what are all the strings you are able to prove. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
你可能注意到了推理规则只能证明比已经有的字符串更短的字符串。这意味着，我给你有限多个公理之后，你基本上就能确定你总共能证明出哪些字符串了。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Indeed. I think in the last level I cannot prove any other string than those I have proved. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
确实。我觉得在上一关里我证明不出来除了我已经证明好的字符串以外的任何别的字符串了。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
That is why you will normally be given infinitely many axioms. In particular, you are given **axiom schemas**. An axiom schema is a rule that specify which strings are axioms: for instance, this time I will give you the axiom schema $\varphi\to\psi\to\varphi$, which says $\varphi\to\psi\to\varphi$ is an axiom for each formula $\varphi$ and $\psi$. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
这就是为什么之后一般来说我会给你无穷多个公理。具体来说，我会给你一些**公理模式**。一个公理模式是一条指定了哪些字符串是公理的规则：比如说，这次我会给你公理模式 $\varphi\to\psi\to\varphi$，它的意思是对任意**公式** $\varphi$ 和 $\psi$，$\varphi\to\psi\to\varphi$ 都是一个公理。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Humm, the axiom says if I can prove $\varphi$ and $\psi$ then I can prove $\varphi$. Sounds correct. So I can prove <FormulaLatex formula={ptoqtop} /> as it is an axiom specified by the axiom schema. Uh, wait, formulas? Although I already feel like these strings should be called formulas, but you finally admitted it! But what exactly is a formula, just any string? 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
唔，这个公理的意思是如果我能证明 $\varphi$ 和 $\psi$ 那我就能证明 $\varphi$。听起来没错。所以我能证明 <FormulaLatex formula={ptoqtop} />，因为它是这个公理模式指定的一个公理。呃，等等，公式？虽然我已经觉得这些字符串应该叫公式了，但你终于承认了！不过公式到底是什么，是任意字符串吗？
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Generally, a formula cannot be every string, it needs to be a string that makes sense: as a counterexample, $\to p\to\to$ is not a formula. That said, every string you'll encounter and deal with in this chapter will be a formula. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
一般来说，不是每个字符串都是公式，公式需要是个有意义的字符串：作为反例，$\to p\to\to$ 就不是公式。虽然这么说，你这一章里遇到和处理的所有字符串都会是公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
More precisely, an **atomic formula** is some letter or word that you like, and every atomic formula is a formula. In addition, if $\varphi$ and $\psi$ are both formulas, then $\varphi\to\psi$ is also a formula. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
具体来说，一个**原子公式**是任何你喜欢的字母或者单词，每个原子公式都是公式。以及，如果 $\varphi$ 和 $\psi$ 都是公式，那么 $\varphi\to\psi$ 也是公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
<Sapphire /> often use atomic formulas <FormulaLatex formula={p} />, <FormulaLatex formula={parseFormula("q")} />, <FormulaLatex formula={parseFormula("r")} />, but you can certainly use <FormulaLatex formula={parseFormula("t_5^7")} /> or <FormulaLatex formula={parseFormula("apple")} /> as an atomic formula if you want. Although recently the atomic formulas <Sapphire /> gives you are enough. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
<Sapphire />平常用的原子公式是 <FormulaLatex formula={p} />，<FormulaLatex formula={parseFormula("q")} />，<FormulaLatex formula={parseFormula("r")} />，但你想的话当然可以用 <FormulaLatex formula={parseFormula("t_5^7")} /> 或者 <FormulaLatex formula={parseFormula("apple")} /> 作为原子公式，不过短时间内你就用<Sapphire />给你的原子公式就够了。
</LocalizedMarkdown>
</Speak>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
That's it? I was expecting more strings to be formulas. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
就这些？我还以为还有更多的字符串会是公式呢。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
That's it, well, for now. Later there will be some more. Back to the axiom schema, you can also set $\varphi$ to be <FormulaLatex formula={qtop} /> and $\psi$ to be <FormulaLatex formula={p} />, therefore you can prove <FormulaLatex formula={conclusion} />. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
就这些，呃，现在就这些。之后还有些别的。回到这个公理模式，你也可以让 $\varphi$ 是 <FormulaLatex formula={qtop} />，$\psi$ 是 <FormulaLatex formula={p} />，这样就能证明 <FormulaLatex formula={conclusion} />。
</LocalizedMarkdown>
</Speak>

<Speak speaker="author">
<LocalizedMarkdown locale="en">
To use an axiom schema, you can type `axiom` or `axi`, and then either: 

- As before, provide a formula that matches any of the axiom achema given, or provide a line number to refer to such a formula. For instance, you can simply type `axiom p->q->p` to prove <FormulaLatex formula={ptoqtop} />. 
- Or, type a `$` symbol followed by the name of the axiom schema, in which case `weakening` or `wea` for the axiom schema in this level. Then you also need to provide two formulas specifying $\varphi$ and $\psi$. For instance, you can also type `axiom $weakening p q` to prove <FormulaLatex formula={ptoqtop} />. 

You can also click the axiom schema in the inventory to auto-fill `axiom $weakening`. The axiom in the inventory is still displayed as <FormulaLatex formula={ptoqtop} />: If $\varphi$ and $\psi$ are not provided in the second case, they are automatically assigned to <FormulaLatex formula={p} /> and <FormulaLatex formula={q} />. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
要使用一个公理模式，你可以输入 `axiom` 或 `axi`，然后有两种方式：

- 像之前一样，提供一个符合任意公理模式的公式，或者提供一个行号来引用这样的公式。比如说，你可以直接输入 `axiom p->q->p` 来证明 <FormulaLatex formula={ptoqtop} />。
- 或者，输入一个 `$` 符号后跟公理模式的名字，对于这一关来说是 `weakening` 或 `wea`。然后你还需要提供两个公式来指定 $\varphi$ 和 $\psi$。比如说，你也可以输入 `axiom $weakening p q` 来证明 <FormulaLatex formula={ptoqtop} />。

你也可以点击物品栏里的公理模式来自动填写 `axiom $weakening`。物品栏中的公理模式仍然写作 <FormulaLatex formula={ptoqtop} />：如果你在第二种使用方式中不提供 $\varphi$ 和 $\psi$，它们会被自动指定成 <FormulaLatex formula={p} /> 和 <FormulaLatex formula={q} />。
</LocalizedMarkdown>
</Speak>

<ResumeUntil condition={ (level, _) => level.isCompleteOrModified() } text="ConversationProgresser.CompleteLevelToContinue"/>

<Speak speaker="star">
<LocalizedMarkdown locale="en">
Looks like I can prove a lot of formulas using this axiom schema. 
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
看起来我能用这个公理模式证明好多公式。
</LocalizedMarkdown>
</Speak>

<Speak speaker="sapphire">
<LocalizedMarkdown locale="en">
Yes, and that also means you'll need to think creatively to know which axioms you need to use to prove the target formula.
</LocalizedMarkdown>
<LocalizedMarkdown locale="zh">
是的，这也意味着你需要创造性地思考才能知道需要用哪些公理来证明目标公式。
</LocalizedMarkdown>
</Speak>

</ConversationProgresser>
